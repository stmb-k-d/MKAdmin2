{% extends 'dashboard/base.html' %}
{% load static %}
{% load dashboard_tags %}

{% block title %}{{ title|default:'Статистика Facebook' }}{% endblock %}

{% block page_title %}{{ page_title|default:'Статистика Facebook' }}{% endblock %}

{% block extra_head %}
<style>
    /* Основной контейнер с прокруткой */
    .table-container {
        width: 100%;
        overflow-x: auto;
        max-height: 85vh;
        overflow-y: auto;
    }
    
    /* Фильтр по датам */
    .date-filter .input-group {
        width: auto;
    }
    
    .date-filter input[type="date"] {
        width: 130px;
    }
    
    /* Стили для статусов fb_effective_status */
    .status-active {
        background-color: #28a745 !important;
        color: #fff !important;
        font-weight: bold;
    }
    
    .status-paused, .status-adset_paused, .status-campaign_paused {
        background-color: #ffc107 !important;
        color: #000 !important;
        font-weight: bold;
    }
    
    .status-deleted, .status-disapproved, .status-rejected {
        background-color: #dc3545 !important;
        color: #fff !important;
        font-weight: bold;
    }
    
    .status-archived {
        background-color: #6c757d !important;
        color: #fff !important;
        font-weight: bold;
    }
    
    .status-pending, .status-in_review {
        background-color: #17a2b8 !important;
        color: #fff !important;
        font-weight: bold;
    }
    
    .status-with_issues {
        background-color: #9c27b0 !important;
        color: #fff !important;
        font-weight: bold;
    }
    
    /* Стили для статусов fb_status (более тусклые) */
    .status-fb-active {
        background-color: rgba(40, 167, 69, 0.6) !important;
        color: #fff !important;
    }
    
    .status-fb-paused, .status-fb-adset_paused, .status-fb-campaign_paused {
        background-color: rgba(255, 193, 7, 0.6) !important;
        color: #000 !important;
    }
    
    .status-fb-deleted, .status-fb-disapproved, .status-fb-rejected {
        background-color: rgba(220, 53, 69, 0.6) !important;
        color: #fff !important;
    }
    
    .status-fb-archived {
        background-color: rgba(108, 117, 125, 0.6) !important;
        color: #fff !important;
    }
    
    .status-fb-pending, .status-fb-in_review {
        background-color: rgba(23, 162, 184, 0.6) !important;
        color: #fff !important;
    }
    
    .status-fb-with_issues {
        background-color: rgba(156, 39, 176, 0.6) !important;
        color: #fff !important;
    }
    
    /* Стили для легенды статусов */
    .status-legend {
        background-color: #f8f9fa;
        border-radius: 0 0 .25rem .25rem;
    }
    
    .status-badge {
        border-radius: 4px;
    }
    
    /* Основные стили таблицы */
    #statsTable {
        font-size: 0.65rem;
        width: 100%;
        table-layout: auto;
        border-collapse: collapse;
    }
    
    /* Ячейки таблицы */
    #statsTable th, 
    #statsTable td {
        text-align: center;
        vertical-align: middle;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        padding: 3px;
        border: 1px solid #dee2e6;
    }
    
    /* Заголовки */
    #statsTable th {
        background-color: #f8f9fa;
        font-weight: bold;
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    /* Строки */
    #statsTable tr:nth-child(even) {
        background-color: rgba(0, 0, 0, 0.02);
    }
    
    #statsTable tr:hover {
        background-color: rgba(0, 0, 0, 0.05);
    }
    
    /* Выделенная строка */
    #statsTable tbody tr.highlighted {
        background-color: rgba(40, 167, 69, 0.15) !important;
    }
    
    /* Стили для итоговой строки */
    #statsTable tbody tr.total-row {
        background-color: #f8f9fa !important;
        font-weight: bold;
        border-top: 2px solid #dee2e6;
    }
    
    #statsTable tbody tr.total-row td {
        border-top: 2px solid #dee2e6;
    }
    
    #statsTable tbody tr.total-row:hover {
        background-color: #e9ecef !important;
    }
    
    /* Стили для сортировки */
    #statsTable th.sorting {
        cursor: pointer;
        position: relative;
    }
    
    #statsTable th.sorting:after {
        content: '↕';
        position: absolute;
        right: 5px;
        opacity: 0.5;
    }
    
    #statsTable th.sorting_asc:after {
        content: '↓';
        opacity: 1;
    }
    
    #statsTable th.sorting_desc:after {
        content: '↑';
        opacity: 1;
    }
    
    /* Стили для модального окна выбора колонок */
    .column-selection-modal .modal-body {
        max-height: 70vh;
        overflow-y: auto;
    }
    
    .column-selection-container {
        display: flex;
        flex-direction: column;
    }
    
    .column-checkbox-container {
        padding: 8px;
        margin-bottom: 5px;
        border: 1px solid #e9ecef;
        border-radius: 4px;
        display: flex;
        align-items: center;
        background-color: #f8f9fa;
    }
    
    .column-checkbox-container:hover {
        background-color: #e9ecef;
    }
    
    .column-checkbox-container .drag-handle {
        cursor: move;
        margin-right: 10px;
        color: #6c757d;
    }
    
    .column-checkbox-container .form-check {
        margin-bottom: 0;
        flex-grow: 1;
    }
    
    /* Стиль для перетаскиваемого элемента */
    .column-checkbox-container.dragging {
        opacity: 0.5;
        border: 1px dashed #0d6efd;
    }
    
    /* Кнопки управления колонками */
    .column-buttons {
        margin-left: 10px;
    }
    
    /* Стили для блока с фильтрами и управлением */
    .table-controls-block {
        background-color: #f8f9fa;
        border-radius: 5px;
        margin-bottom: 15px;
        padding: 15px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .table-controls-block .refresh-btn {
        margin-left: 15px;
    }
    
    /* Стили для колонок с полным отображением содержимого */
    .width-auto-column {
        min-width: 120px !important;
        width: auto !important;
        white-space: normal !important;
        overflow: visible !important;
        text-overflow: initial !important;
    }
    
    /* Специальные стили для колонок ad_id и last_update */
    #statsTable th.column-ad_id,
    #statsTable td.column-ad_id,
    #statsTable th.column-last_update,
    #statsTable td.column-last_update {
        min-width: 120px;
        width: auto !important;
        max-width: none !important; 
        white-space: nowrap !important;
        overflow: visible !important;
        text-overflow: clip !important;
        flex-shrink: 0;
    }
    
    /* Дополнительные стили для переключателя "Активные" */
    .form-check-input:checked {
        background-color: #28a745;
        border-color: #28a745;
    }
    
    .active-filter-enabled {
        color: #28a745;
        font-weight: bold;
    }
</style>
<!-- CSS для выбора диапазона дат -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.css" />
{% endblock %}

{% block content %}
<div class="card">
    <div class="card-header d-flex justify-content-between align-items-center">
        <div class="d-flex align-items-center">
            <h5 class="mb-0 me-3">Статистика Facebook</h5>
        </div>
    </div>
    <div class="card-body">
        <!-- Новый блок с фильтрами и управлением -->
        <div class="table-controls-block">
            <div class="d-flex flex-wrap justify-content-between align-items-center">
                <div class="d-flex flex-wrap align-items-center">
                    <div class="date-filter me-3">
                        <div class="input-group">
                            <!-- Видимый комбинированный фильтр периода -->
                            <input type="text" id="dateRange" class="form-control form-control-sm" placeholder="Период">
                            <!-- Сохраняем оригинальные поля, но скрываем их, чтобы не ломать существующий JS -->
                            <input type="hidden" id="dateFrom">
                            <input type="hidden" id="dateTo">
                            <button id="applyDateFilter" class="btn btn-sm btn-primary">
                                <i class="fas fa-filter"></i>
                            </button>
                            <button id="resetDateFilter" class="btn btn-sm btn-outline-secondary">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                    <!-- Добавляем переключатель "Активные" -->
                    <div class="form-check form-switch me-3">
                        <input class="form-check-input" type="checkbox" id="activeOnlyFilter">
                        <label class="form-check-label" for="activeOnlyFilter">Активные</label>
                    </div>
                    <div class="column-buttons me-3">
                        <button type="button" class="btn btn-outline-primary btn-sm" data-bs-toggle="modal" data-bs-target="#columnSelectionModal">
                            <i class="fas fa-columns"></i> Настроить колонки
                        </button>
                    </div>
                    <!-- Кнопка фильтров -->
                    <div class="d-flex gap-2 me-3">
                        <button type="button" class="btn btn-outline-secondary btn-sm" id="showFiltersBtn" data-bs-toggle="modal" data-bs-target="#filtersModal">
                            <i class="fas fa-filter"></i> Фильтры
                        </button>
                        <button type="button" class="btn btn-outline-danger btn-sm d-none" id="resetFiltersBtn">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <button id="refreshTable" class="btn btn-outline-primary btn-sm refresh-btn">
                        <i class="fas fa-sync-alt"></i> Обновить таблицу
                    </button>
                    <button id="downloadCsvBtn" class="btn btn-outline-secondary btn-sm ms-2">
                        <i class="fas fa-download"></i> Скачать CSV
                    </button>
                </div>
                <div>
                    <input type="text" id="searchInput" class="form-control form-control-sm" placeholder="Поиск...">
                </div>
            </div>
        </div>
        
        {% if error %}
        <div class="alert alert-danger m-3">
            {{ error }}
        </div>
        {% else %}
        {% if date_from or date_to %}
        <div class="alert alert-info m-3 d-flex justify-content-between align-items-center">
            <div>
                <i class="fas fa-filter"></i> 
                Активный фильтр: 
                {% if date_from %}с {{ date_from }}{% endif %}
                {% if date_to %}по {{ date_to }}{% endif %}
            </div>
            <a href="{% url 'dashboard:facebook_stats' %}" class="btn btn-sm btn-outline-secondary">
                <i class="fas fa-times"></i> Сбросить
            </a>
        </div>
        {% endif %}
        <div class="table-container">
            <table id="statsTable" class="table table-bordered">
                <thead>
                    <tr id="tableHeader">
                        <!-- Заголовки будут добавлены динамически через JavaScript -->
                    </tr>
                </thead>
                <tbody id="tableBody">
                    <!-- Строки будут добавлены динамически через JavaScript -->
                </tbody>
            </table>
        </div>
        
        <!-- Легенда статусов -->
        <div class="status-legend p-3 border-top">
            <h6 class="mb-2">Статусы объявлений:</h6>
            <div class="d-flex flex-wrap gap-2">
                <div class="d-flex align-items-center">
                    <span class="status-badge status-active d-inline-block me-1" style="width: 16px; height: 16px;"></span>
                    <small>Active</small>
                </div>
                <div class="d-flex align-items-center">
                    <span class="status-badge status-paused d-inline-block me-1" style="width: 16px; height: 16px;"></span>
                    <small>Paused/ADSET_PAUSED/CAMPAIGN_PAUSED</small>
                </div>
                <div class="d-flex align-items-center">
                    <span class="status-badge status-deleted d-inline-block me-1" style="width: 16px; height: 16px;"></span>
                    <small>Deleted/Disapproved</small>
                </div>
                <div class="d-flex align-items-center">
                    <span class="status-badge status-archived d-inline-block me-1" style="width: 16px; height: 16px;"></span>
                    <small>Archived</small>
                </div>
                <div class="d-flex align-items-center">
                    <span class="status-badge status-pending d-inline-block me-1" style="width: 16px; height: 16px;"></span>
                    <small>Pending/In Review</small>
                </div>
                <div class="d-flex align-items-center">
                    <span class="status-badge status-with_issues d-inline-block me-1" style="width: 16px; height: 16px;"></span>
                    <small>With Issues</small>
                </div>
            </div>
            <small class="text-muted mt-2 d-block">* Примечание: Статусы в колонке fb_status выделены менее ярко, чем в fb_effective_status</small>
        </div>

        {% endif %}
    </div>
</div>

<!-- Модальное окно для выбора колонок -->
<div class="modal fade column-selection-modal" id="columnSelectionModal" tabindex="-1" aria-labelledby="columnSelectionModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="columnSelectionModalLabel">Выбор отображаемых колонок</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info mb-3">
                    <small>Перетащите элементы, чтобы изменить порядок колонок в таблице.</small>
                </div>
                <div class="mb-3 d-flex">
                    <div class="form-check form-switch me-3">
                        <input class="form-check-input" type="checkbox" id="selectAllColumns">
                        <label class="form-check-label" for="selectAllColumns">Выбрать все колонки</label>
                    </div>
                    <div class="d-flex gap-2">
                        <button type="button" class="btn btn-outline-secondary btn-sm" id="resetToDefaultColumns">Сбросить</button>
                        <button type="button" class="btn btn-outline-primary btn-sm" id="saveAsDefaultColumns">Сохранить как шаблон</button>
                    </div>
                </div>
                <div class="column-selection-container" id="columnCheckboxes">
                    <!-- Чекбоксы для колонок будут добавлены динамически через JavaScript -->
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                <button type="button" class="btn btn-primary" id="saveColumnSelection" data-bs-dismiss="modal">Применить</button>
            </div>
        </div>
    </div>
</div>

<!-- Модальное окно для фильтров -->
<div class="modal fade" id="filtersModal" tabindex="-1" aria-labelledby="filtersModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="filtersModalLabel">Настройка фильтров</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info mb-3">
                    <small>Добавьте фильтры по нужным колонкам для уточнения выборки данных.</small>
                </div>
                <div class="mb-3 d-flex justify-content-between">
                    <button type="button" class="btn btn-outline-primary btn-sm" id="addFilterBtn">
                        <i class="fas fa-plus"></i> Добавить фильтр
                    </button>
                    <button type="button" class="btn btn-outline-danger btn-sm" id="clearAllFiltersBtn">
                        <i class="fas fa-trash"></i> Очистить все фильтры
                    </button>
                </div>
                <div id="filtersContainer"><!-- динамически --></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                <button type="button" class="btn btn-primary" id="applyFiltersBtn" data-bs-dismiss="modal">Применить фильтры</button>
            </div>
        </div>
    </div>
</div>

<!-- Скрипт для выделения строк -->
<script>
function highlightRow(row, event) {
    // Проверяем, что клик не на ссылку или span внутри ячейки
    if (event.target.tagName.toLowerCase() === 'a' || 
        event.target.parentElement.tagName.toLowerCase() === 'a') {
        return;
    }
    
    // Проверяем, выделена ли уже строка
    if (row.classList.contains('highlighted')) {
        // Если строка выделена, снимаем выделение
        row.classList.remove('highlighted');
    } else {
        // Снимаем выделение со всех строк
        const rows = document.querySelectorAll('#statsTable tbody tr');
        rows.forEach(r => r.classList.remove('highlighted'));
        
        // Выделяем текущую строку
        row.classList.add('highlighted');
    }
}
</script>
{% endblock %}

{% block extra_js %}
<!-- Moment.js и Daterangepicker (только для этой страницы) -->
<script src="https://cdn.jsdelivr.net/momentjs/latest/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.min.js"></script>
<script>
$(document).ready(function() {
    // Подключаем moment и daterangepicker (если они еще не подключены глобально)
    // ... existing code ...
    
    // Инициализация элементов фильтра по датам
    const dateFrom = document.getElementById('dateFrom');
    const dateTo = document.getElementById('dateTo');
    const applyDateFilter = document.getElementById('applyDateFilter');
    const resetDateFilter = document.getElementById('resetDateFilter');
    const refreshTableBtn = document.getElementById('refreshTable');
    const activeOnlyFilter = document.getElementById('activeOnlyFilter');
    const searchInput = document.getElementById('searchInput');
    
    /* === Daterangepicker и логика скрытых полей === */
    const dateRangeInput = $('#dateRange');

    // Конфиг быстрых диапазонов
    const ranges = {
        'Сегодня': [moment(), moment()],
        'Вчера': [moment().subtract(1, 'days'), moment().subtract(1, 'days')],
        'Последние 7 дней': [moment().subtract(6, 'days'), moment()],
        'Текущая неделя': [moment().startOf('week'), moment().endOf('week')],
        'Текущий месяц': [moment().startOf('month'), moment().endOf('month')],
        'Предыдущий месяц': [moment().subtract(1, 'month').startOf('month'), moment().subtract(1, 'month').endOf('month')],
        'Последние 30 дней': [moment().subtract(29, 'days'), moment()]
    };

    // Устанавливаем начальное значение видимого поля из URL или шаблона
    let initialStart = moment(dateFrom ? dateFrom.value : undefined);
    let initialEnd   = moment(dateTo ? dateTo.value : undefined);
    if (!initialStart.isValid()) initialStart = moment().subtract(1, 'month');
    if (!initialEnd.isValid())   initialEnd   = moment();

    function setHiddenFields(start, end) {
        // Обновляем скрытые input, чтобы остальной код продолжал работать
        dateFrom.value = start.format('YYYY-MM-DD');
        dateTo.value   = end.format('YYYY-MM-DD');
    }

    setHiddenFields(initialStart, initialEnd);

    dateRangeInput.daterangepicker({
        startDate: initialStart,
        endDate: initialEnd,
        locale: {
            format: 'YYYY-MM-DD',
            applyLabel: 'Применить',
            cancelLabel: 'Отмена',
            fromLabel: 'С',
            toLabel: 'По',
            customRangeLabel: 'Произвольный',
            daysOfWeek: ['Вс', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб'],
            monthNames: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
            firstDay: 1
        },
        ranges: ranges,
        opens: 'left',
        autoUpdateInput: true,
    }, function(start, end) {
        setHiddenFields(start, end);
    });

    // При клике на resetDateFilter очищаем и видимое поле
    $('#resetDateFilter').on('click', function() {
        dateRangeInput.val('');
        dateFrom.value = '';
        dateTo.value = '';
        // Дополнительно обновляем URL как и раньше
        const currentUrl = new URL(window.location.href);
        currentUrl.searchParams.delete('date_from');
        currentUrl.searchParams.delete('date_to');
        window.location.href = currentUrl.toString();
    });
    
    // Восстанавливаем состояние переключателя "Активные" из localStorage
    try {
        const activeOnlyState = localStorage.getItem('fbStatsActiveOnly');
        if (activeOnlyState === 'true') {
            activeOnlyFilter.checked = true;
            // Обновляем только стиль лейбла
            const label = document.querySelector('label[for="activeOnlyFilter"]');
            label.classList.add('active-filter-enabled');
        }
    } catch (e) {
        console.error('Ошибка при восстановлении состояния переключателя "Активные":', e);
    }
    
    // Установка начальных значений дат (последний месяц)
    const today = new Date();
    const lastMonth = new Date();
    lastMonth.setMonth(today.getMonth() - 1);
    
    // Получение параметров из URL, если они есть
    const urlParams = new URLSearchParams(window.location.search);
    const urlDateFrom = urlParams.get('date_from');
    const urlDateTo = urlParams.get('date_to');
    
    // Если параметры есть в URL, устанавливаем их, иначе используем значения по умолчанию
    if (urlDateFrom) {
        dateFrom.value = urlDateFrom;
    } else {
        {% if date_from %}
        dateFrom.value = "{{ date_from }}";
        {% else %}
        dateFrom.value = lastMonth.toISOString().split('T')[0];
        {% endif %}
    }
    
    if (urlDateTo) {
        dateTo.value = urlDateTo;
    } else {
        {% if date_to %}
        dateTo.value = "{{ date_to }}";
        {% else %}
        dateTo.value = today.toISOString().split('T')[0];
        {% endif %}
    }
    
    // Синхронизируем видимое поле после возможного изменения скрытых дат вышестоящим кодом
    if (dateFrom.value && dateTo.value) {
        const drp = dateRangeInput.data('daterangepicker');
        if (drp) {
            drp.setStartDate(moment(dateFrom.value));
            drp.setEndDate(moment(dateTo.value));
            dateRangeInput.val(dateFrom.value + ' - ' + dateTo.value);
        }
    }
    
    // Обработчик кнопки применения фильтра
    applyDateFilter.addEventListener('click', function() {
        if (dateFrom.value && dateTo.value) {
            // Формируем URL с параметрами дат
            const currentUrl = new URL(window.location.href);
            currentUrl.searchParams.set('date_from', dateFrom.value);
            currentUrl.searchParams.set('date_to', dateTo.value);
            
            // Переходим по новому URL с фильтрами
            window.location.href = currentUrl.toString();
        } else {
            alert('Пожалуйста, выберите диапазон дат');
        }
    });
    
    // Глобальная переменная для хранения таймаута
    let refreshTimeout = null;
    // Флаг, указывающий, что запрос в процессе выполнения
    let isRefreshing = false;

    // Обработчик для кнопки "Обновить таблицу"
    refreshTableBtn.addEventListener('click', function() {
        // Если обновление уже выполняется, не делаем ничего
        if (isRefreshing) {
            console.log('Обновление уже выполняется...');
            return;
        }
        
        // Устанавливаем флаг, что запрос в процессе выполнения
        isRefreshing = true;
        
        // Очищаем предыдущий таймаут, если он есть
        if (refreshTimeout) {
            clearTimeout(refreshTimeout);
            refreshTimeout = null;
        }
        
        // Сохраняем ссылку на кнопку
        const button = this;
        
        // Сохраняем оригинальное содержимое и классы кнопки
        const originalContent = button.innerHTML;
        const originalClasses = Array.from(button.classList);
        
        // Показываем индикатор загрузки в кнопке
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Обновление...';
        button.disabled = true;
        
        // Получаем текущие параметры фильтров
        const urlParams = new URLSearchParams(window.location.search);
        const dateFrom = urlParams.get('date_from') || '';
        const dateTo = urlParams.get('date_to') || '';
        
        // Формируем URL для AJAX запроса
        let apiUrl = '{% url 'dashboard:facebook_stats' %}';
        if (dateFrom || dateTo) {
            apiUrl = `${apiUrl}?date_from=${dateFrom}&date_to=${dateTo}`;
        }
        
        // Функция для восстановления исходного состояния кнопки
        function resetButtonState() {
            button.innerHTML = originalContent;
            button.disabled = false;
            // Корректно восстанавливаем все классы
            button.className = '';
            originalClasses.forEach(cls => button.classList.add(cls));
            isRefreshing = false;
        }
        
        // Показываем пользователю визуальную индикацию статуса обновления
        function showUpdateStatus(success, message = '') {
            const statusElement = document.createElement('div');
            statusElement.id = 'updateStatusMessage';
            statusElement.style.cssText = 'position:fixed; top:20px; right:20px; padding:10px 15px; border-radius:4px; z-index:9999; box-shadow:0 2px 10px rgba(0,0,0,0.2);';
            
            if (success) {
                statusElement.style.backgroundColor = '#0d6efd'; // Синий (primary) цвет вместо зеленого
                statusElement.style.color = '#fff';
                statusElement.innerHTML = '<i class="fas fa-check-circle"></i> ' + (message || 'Таблица успешно обновлена');
            } else {
                statusElement.style.backgroundColor = '#dc3545';
                statusElement.style.color = '#fff';
                statusElement.innerHTML = `<i class="fas fa-exclamation-circle"></i> ${message || 'Ошибка при обновлении таблицы'}`;
            }
            
            // Удаляем предыдущее сообщение, если есть
            const oldStatus = document.getElementById('updateStatusMessage');
            if (oldStatus) {
                oldStatus.remove();
            }
            
            document.body.appendChild(statusElement);
            
            // Автоматически скрываем через 5 секунд
            setTimeout(() => {
                if (statusElement.parentNode) {
                    statusElement.remove();
                }
            }, 5000);
        }
        
        // Выполняем AJAX запрос для получения обновленных данных
        fetch(apiUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Ошибка HTTP: ${response.status}`);
                }
                return response.text();
            })
            .then(html => {
                try {
                    // Создаем временный DOM для обработки HTML
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    // Извлекаем скрипт, содержащий данные для таблицы
                    const scriptContent = Array.from(doc.querySelectorAll('script'))
                        .find(script => script.textContent.includes('const statsData = ['));
                    
                    if (!scriptContent) {
                        throw new Error('Не найден скрипт с данными в ответе сервера');
                    }
                    
                    // Получаем строку с данными
                    const scriptText = scriptContent.textContent;
                    
                    // Извлекаем данные из скрипта регулярным выражением
                    const dataMatch = scriptText.match(/const statsData = (\[[\s\S]*?\]);/);
                    
                    if (!dataMatch || !dataMatch[1]) {
                        throw new Error('Не удалось найти данные в полученном ответе');
                    }
                    
                    try {
                        // Получаем строку с данными и логируем её для отладки
                        let jsonString = dataMatch[1];
                        console.log('Получена строка данных длиной:', jsonString.length);
                        
                        // Функция для обновления таблицы с новыми данными
                        function updateTableWithNewData(newStatsData) {
                            // Сохраняем предыдущее количество для сравнения
                            const prevDataCount = statsData.length;
                            
                            // Обновляем глобальную переменную
                            statsData = newStatsData;
                            
                            // Перестраиваем таблицу с новыми данными
                            refreshDataSource();
                            buildTable();
                            applySearchFilter(document.getElementById('searchInput').value);
                            
                            // Показываем анимацию успешного обновления в кнопке
                            button.className = '';
                            originalClasses.forEach(cls => button.classList.add(cls));
                            button.classList.add('btn-outline-primary');
                            button.classList.remove('btn-sm');
                            button.innerHTML = '<i class="fas fa-check"></i> Обновлено';
                            
                            // Показываем уведомление об успешном обновлении с информацией
                            showUpdateStatus(true, `Данные обновлены: ${prevDataCount} → ${newStatsData.length} записей`);
                            console.log(`Таблица обновлена: ${prevDataCount} → ${newStatsData.length} записей`);
                            
                            // Через 2 секунды возвращаем кнопку в исходное состояние
                            refreshTimeout = setTimeout(() => {
                                resetButtonState();
                                refreshTimeout = null;
                            }, 2000);
                        }
                        
                        // Проверяем, не является ли строка пустым массивом
                        if (jsonString.trim() === '[]') {
                            console.log('Получен пустой массив данных');
                            statsData = [];
                            showUpdateStatus(true, 'Обновлено. Нет данных для отображения.');
                            
                            // Перестраиваем таблицу даже с пустыми данными
                            refreshDataSource();
                            buildTable();
                            
                            // Показываем анимацию успешного обновления в кнопке
                            button.className = '';
                            originalClasses.forEach(cls => button.classList.add(cls));
                            button.classList.add('btn-outline-primary');
                            button.classList.remove('btn-sm');
                            button.innerHTML = '<i class="fas fa-check"></i> Обновлено';
                            
                            // Через 2 секунды возвращаем кнопку в исходное состояние
                            refreshTimeout = setTimeout(() => {
                                resetButtonState();
                                refreshTimeout = null;
                            }, 2000);
                        } else {
                            let parsedSuccessfully = false;
                            let newStatsData = [];
                            
                            // Метод 1: Стандартный JSON.parse
                            try {
                                console.log('Метод 1: Стандартный JSON.parse');
                                newStatsData = JSON.parse(jsonString);
                                console.log('Метод 1 успешен, получено записей:', newStatsData.length);
                                parsedSuccessfully = true;
                            } catch (e) {
                                console.error('Ошибка метода 1:', e);
                                
                                // Метод 2: Предобработка строки перед парсингом
                                try {
                                    console.log('Метод 2: Предобработка JSON строки');
                                    const cleanedJsonString = jsonString
                                        .replace(/\\'/g, "'")     // Заменяем экранированные апострофы
                                        .replace(/\\"/g, '"')     // Заменяем экранированные кавычки
                                        .replace(/\\\\/g, '\\')   // Заменяем двойные обратные слеши
                                        .replace(/\n/g, ' ')      // Заменяем переносы строк
                                        .replace(/\r/g, ' ')      // Заменяем возвраты каретки
                                        .replace(/\t/g, ' ');     // Заменяем табуляции
                                    
                                    newStatsData = JSON.parse(cleanedJsonString);
                                    console.log('Метод 2 успешен, получено записей:', newStatsData.length);
                                    parsedSuccessfully = true;
                                } catch (e2) {
                                    console.error('Ошибка метода 2:', e2);
                                    
                                    // Метод 3: Прямое использование данных из шаблона
                                    // Вместо парсинга JSON, переиспользуем оригинальные данные из шаблона
                                    try {
                                        console.log('Метод 3: Прямое использование данных из страницы');
                                        // Логика: если мы уже на странице, у нас уже есть переменная statsData
                                        // Просто используем ее напрямую
                                        showUpdateStatus(true, 'Данные повторно загружены');
                                        button.className = '';
                                        originalClasses.forEach(cls => button.classList.add(cls));
                                        button.classList.add('btn-outline-primary');
                                        button.classList.remove('btn-sm');
                                        button.innerHTML = '<i class="fas fa-check"></i> Обновлено';
                                        
                                        // Просто перерисовываем таблицу с имеющимися данными
                                        refreshDataSource();
                                        buildTable();
                                        applySearchFilter(document.getElementById('searchInput').value);
                                        
                                        console.log('Метод 3: таблица перерисована с текущими данными');
                                        
                                        // Через 2 секунды возвращаем кнопку в исходное состояние
                                        refreshTimeout = setTimeout(() => {
                                            resetButtonState();
                                            refreshTimeout = null;
                                        }, 2000);
                                        
                                        return; // Выходим из обработчика, так как таблица уже обновлена
                                    } catch (e3) {
                                        console.error('Ошибка метода 3:', e3);
                                        
                                        // Последний вариант - просим пользователя перезагрузить страницу
                                        button.className = '';
                                        originalClasses.forEach(cls => button.classList.add(cls));
                                        button.classList.add('btn-warning');
                                        button.classList.remove('btn-sm');
                                        button.innerHTML = '<i class="fas fa-sync"></i> Требуется перезагрузка';
                                        
                                        showUpdateStatus(false, 'Не удалось обновить данные. Попробуйте перезагрузить страницу.');
                                        
                                        // Добавляем кнопку для перезагрузки
                                        const statusElement = document.getElementById('updateStatusMessage');
                                        if (statusElement) {
                                            const reloadBtn = document.createElement('button');
                                            reloadBtn.className = 'btn btn-sm btn-light mt-2';
                                            reloadBtn.innerHTML = '<i class="fas fa-sync"></i> Перезагрузить страницу';
                                            reloadBtn.onclick = function() { window.location.reload(); };
                                            statusElement.appendChild(document.createElement('br'));
                                            statusElement.appendChild(reloadBtn);
                                        }
                                        
                                        // Через 5 секунд возвращаем кнопку в исходное состояние
                                        refreshTimeout = setTimeout(() => {
                                            resetButtonState();
                                            refreshTimeout = null;
                                        }, 5000);
                                        
                                        isRefreshing = false;
                                        return; // Выходим, чтобы не вызывать дополнительных исключений
                                    }
                                }
                            }
                            
                            // Если удалось распарсить данные одним из методов - обновляем таблицу
                            if (parsedSuccessfully && Array.isArray(newStatsData)) {
                                console.log('Данные успешно получены, обновляем таблицу...');
                                updateTableWithNewData(newStatsData);
                            }
                        }
                    } catch (dataError) {
                        console.error('Общая ошибка при обработке данных:', dataError);
                        button.className = '';
                        originalClasses.forEach(cls => button.classList.add(cls));
                        button.classList.add('btn-danger');
                        button.classList.remove('btn-sm');
                        button.innerHTML = '<i class="fas fa-exclamation-circle"></i> Ошибка';
                        
                        // Показываем уведомление с деталями ошибки
                        showUpdateStatus(false, 'Ошибка при обновлении: ' + dataError.message);
                        
                        // Восстанавливаем состояние кнопки через 3 секунды
                        refreshTimeout = setTimeout(() => {
                            resetButtonState();
                            refreshTimeout = null;
                        }, 3000);
                    }
                } catch (error) {
                    console.error('Ошибка при обработке данных:', error);
                    
                    // Показываем ошибку в кнопке
                    button.className = '';
                    originalClasses.forEach(cls => button.classList.add(cls));
                    button.classList.add('btn-danger');
                    button.classList.remove('btn-sm');
                    button.innerHTML = '<i class="fas fa-exclamation-circle"></i> Ошибка';
                    
                    // Показываем уведомление с деталями ошибки
                    showUpdateStatus(false, error.message);
                    
                    // Через 1.5 секунды возвращаем кнопку в исходное состояние
                    refreshTimeout = setTimeout(() => {
                        resetButtonState();
                        refreshTimeout = null;
                    }, 1500);
                }
            })
            .catch(error => {
                console.error('Ошибка при обновлении данных:', error);
                
                // Показываем ошибку в кнопке
                button.className = '';
                originalClasses.forEach(cls => button.classList.add(cls));
                button.classList.add('btn-danger');
                button.classList.remove('btn-sm');
                button.innerHTML = '<i class="fas fa-exclamation-circle"></i> Ошибка';
                
                // Показываем уведомление с деталями ошибки
                showUpdateStatus(false, error.message);
                
                // Через 1.5 секунды возвращаем кнопку в исходное состояние
                refreshTimeout = setTimeout(() => {
                    resetButtonState();
                    refreshTimeout = null;
                }, 1500);
            });
    });
    
    // Подготовим данные для таблицы
    const statsData = [
    {% for item in data %}
        {
        {% for column in columns %}
            "{{ column }}": "{{ item|get_item:column|default:'-'|escapejs }}",
        {% endfor %}
        }{% if not forloop.last %},{% endif %}
    {% endfor %}
    ];
    
    // Загружаем все доступные колонки
    const allColumns = [{% for column in columns %}"{{ column }}"{% if not forloop.last %}, {% endif %}{% endfor %}];
    console.log("Доступные колонки:", allColumns);
    
    // Изначально выбранные колонки по умолчанию
    const initialDefaultColumns = allColumns.filter(c => c !== 'date_log').slice(0, 15);
    
    // Получаем сохраненные пользовательские настройки колонок из localStorage
    let userColumnSettings = localStorage.getItem('fbStatsColumnSettings');
    let selectedColumns = initialDefaultColumns;
    
    if (userColumnSettings) {
        try {
            userColumnSettings = JSON.parse(userColumnSettings);
            if (Array.isArray(userColumnSettings) && userColumnSettings.length > 0) {
                // Проверяем, что все выбранные колонки существуют в allColumns
                selectedColumns = userColumnSettings.filter(col => allColumns.includes(col));
                // Если после фильтрации список пустой, используем дефолтные колонки
                if (selectedColumns.length === 0) {
                    selectedColumns = initialDefaultColumns;
                }
            }
        } catch (e) {
            console.error("Ошибка при парсинге сохраненных настроек колонок:", e);
            selectedColumns = initialDefaultColumns;
        }
    }
    
    // Глобально убираем date_log из выбранных колонок, чтобы не мешал агрегации
    selectedColumns = selectedColumns.filter(col => col !== 'date_log');
    
    // ---------------- ФИЛЬТРЫ ------------------
    let uniqueValues = {};
    let activeFilters = {};

    function initUniqueValues() {
        uniqueValues = {};
        allColumns.forEach(c => uniqueValues[c] = new Set());
        statsData.forEach(row => {
            allColumns.forEach(c => {
                if (row[c] !== null && row[c] !== undefined) {
                    uniqueValues[c].add(row[c]);
                }
            });
        });
        Object.keys(uniqueValues).forEach(c => uniqueValues[c] = Array.from(uniqueValues[c]).sort());
    }
    initUniqueValues();

    function addFilter(column=null, values=null){
        const filterItem = $('<div>').addClass('filter-item');
        const closeBtn = $('<span>').addClass('close-btn').html('<i class="fas fa-times"></i>').on('click',function(){ $(this).parent().remove();});
        const row = $('<div>').addClass('row');
        const colSel = $('<div>').addClass('col-md-5 mb-2');
        const colSelect = $('<select>').addClass('form-select form-select-sm filter-column-select').append($('<option>').val('').text('- колонка -'));
        allColumns.forEach(col=> colSelect.append($('<option>').val(col).text(col).prop('selected',col===column)) );
        colSel.append($('<label>').addClass('form-label').text('Колонка'), colSelect);
        const valCol = $('<div>').addClass('col-md-7 mb-2');
        const valContainer = $('<div>').addClass('filter-values-container');
        valCol.append(valContainer);
        row.append(colSel,valCol);
        filterItem.append(closeBtn,row);
        $('#filtersContainer').append(filterItem);

        function renderValues(col){
            valContainer.empty();
            if(!col) { valContainer.append($('<p>').addClass('text-muted').text('Сначала выберите колонку')); return;}
            const label=$('<label>').addClass('form-label').text('Значения');
            const list=$('<div>').addClass('filter-value-list');
            (uniqueValues[col]||[]).forEach(v=>{
                const chk=$('<input>').addClass('form-check-input filter-value-checkbox').attr({type:'checkbox',value:v,id:`f-${col}-${v}`});
                if(values&&values.includes(String(v))) chk.prop('checked',true);
                const l=$('<label>').addClass('form-check-label').attr('for',`f-${col}-${v}`).text(v);
                list.append($('<div>').addClass('form-check').append(chk,l));
            });
            valContainer.append(label,list);
        }

        if(column) renderValues(column,values);
        colSelect.on('change',function(){ renderValues(this.value);});
    }

    $('#addFilterBtn').on('click',()=>addFilter());
    $('#clearAllFiltersBtn').on('click',()=>$('#filtersContainer').empty());

    $('#applyFiltersBtn').on('click',function(){
        activeFilters={};
        $('.filter-item').each(function(){
            const col=$(this).find('.filter-column-select').val();
            if(!col) return;
            const vals=$(this).find('.filter-value-checkbox:checked').map((_,el)=>$(el).val()).get();
            if(vals.length) activeFilters[col]=vals;
        });
        // индикатор
        $('.active-filters-indicator').remove();
        if(Object.keys(activeFilters).length){
            $('#resetFiltersBtn').removeClass('d-none');
            $('#showFiltersBtn').append($('<span>').addClass('active-filters-indicator').text(Object.keys(activeFilters).length));
        }else{
            $('#resetFiltersBtn').addClass('d-none');
        }
        buildTable();
    });

    $('#resetFiltersBtn').on('click',function(){ activeFilters={}; $(this).addClass('d-none'); $('.active-filters-indicator').remove(); buildTable(); });

    $('#filtersModal').on('show.bs.modal',function(){ $('#filtersContainer').empty(); if(Object.keys(activeFilters).length){ for(const [c,v] of Object.entries(activeFilters)) addFilter(c,v); } else addFilter(); });

    // --------- конец фильтров ----------

    // Глобальные переменные для хранения текущей сортировки
    let currentSortColumn = '';
    let currentSortDirection = '';

    // Функция для построения таблицы на основе выбранных колонок
    function buildTable(skipRefresh = false) {
        if (!skipRefresh) {
            refreshDataSource(); // обновляем источник данных в зависимости от date_log
        }
        console.log("Построение таблицы");
        const tableHeader = document.getElementById('tableHeader');
        const tableBody = document.getElementById('tableBody');
        
        // Очищаем заголовок и тело таблицы
        tableHeader.innerHTML = '';
        tableBody.innerHTML = '';
        
        // Создаем заголовки таблицы
        selectedColumns.forEach(column => {
            const th = document.createElement('th');
            th.textContent = column;
            th.className = 'sorting';
            
            // Добавляем специальные классы для колонок ad_id и last_update
            if (column === 'ad_id') {
                th.classList.add('column-ad_id');
            } else if (column === 'last_update') {
                th.classList.add('column-last_update');
            }
            
            // Восстанавливаем классы сортировки, если этот столбец был отсортирован
            if (column === currentSortColumn) {
                if (currentSortDirection === 'asc') {
                    th.classList.add('sorting_asc');
                } else if (currentSortDirection === 'desc') {
                    th.classList.add('sorting_desc');
                }
            }
            
            th.addEventListener('click', () => sortTable(column));
            tableHeader.appendChild(th);
        });
        
        // Создаем строки таблицы
        currentTableData.forEach(item => {
            const tr = document.createElement('tr');
            tr.addEventListener('click', (event) => highlightRow(tr, event));
            
            selectedColumns.forEach(column => {
                const td = document.createElement('td');
                
                // Добавляем специальные классы для колонок ad_id и last_update
                if (column === 'ad_id') {
                    td.classList.add('column-ad_id');
                } else if (column === 'last_update') {
                    td.classList.add('column-last_update');
                }
                
                const value = item[column];
                
                // Создаем ссылку для колонки ad_id
                if (column === 'ad_id' && value && value !== '-') {
                    const link = document.createElement('a');
                    link.href = `/ad/${value}/`;
                    link.className = 'text-primary';
                    link.textContent = value;
                    td.appendChild(link);
                } else if (column === 'last_update' && value && value !== '-') {
                    // Форматируем дату для колонки last_update в формат "2025-04-24 14:34:34"
                    try {
                        // Пытаемся преобразовать строку в объект даты
                        const dateObj = new Date(value);
                        if (!isNaN(dateObj.getTime())) {
                            // Форматируем дату в нужный формат
                            const year = dateObj.getFullYear();
                            const month = String(dateObj.getMonth() + 1).padStart(2, '0');
                            const day = String(dateObj.getDate()).padStart(2, '0');
                            const hours = String(dateObj.getHours()).padStart(2, '0');
                            const minutes = String(dateObj.getMinutes()).padStart(2, '0');
                            const seconds = String(dateObj.getSeconds()).padStart(2, '0');
                            
                            const formattedDate = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
                            td.textContent = formattedDate;
                        } else {
                            td.textContent = value;
                        }
                    } catch (e) {
                        // Если возникла ошибка при парсинге даты, оставляем исходное значение
                        td.textContent = value;
                    }
                } else {
                    // Форматируем число: если есть дробная часть → 2 знака
                    if (value !== null && value !== undefined && value !== '' && !isNaN(value) && /^-?\d*\.\d+$/.test(String(value))) {
                        td.textContent = parseFloat(value).toFixed(2);
                    } else {
                        td.textContent = value !== null ? value : '-';
                    }
                }
                
                // Дополнительные стили в зависимости от типа данных и форматирование
                if (column === 'date_log') {
                    td.classList.add('date-cell');
                } else if (column.includes('spend') || column.includes('cpc') || column.includes('cpm')) {
                    td.classList.add('numeric-cell');
                } else if (column.includes('ctr') || column.includes('cr')) {
                    td.classList.add('percent-cell');
                }
                
                // Ограничение знаков после запятой для cpi и cpr
                if ((column === 'cpi' || column === 'cpr') && value && value !== '-') {
                    try {
                        const numValue = parseFloat(value);
                        if (!isNaN(numValue)) {
                            td.textContent = numValue.toFixed(2);
                        }
                    } catch (e) {
                        // В случае ошибки оставляем исходное значение
                        console.error(`Ошибка форматирования ${column}:`, e);
                    }
                }
                
                // Добавляем стили для статусов
                if (column === 'fb_effective_status' && value) {
                    const statusClass = 'status-' + value.toLowerCase().replace(/\s+/g, '_');
                    td.classList.add(statusClass);
                } else if (column === 'fb_status' && value) {
                    const statusClass = 'status-fb-' + value.toLowerCase().replace(/\s+/g, '_');
                    td.classList.add(statusClass);
                }
                
                tr.appendChild(td);
            });
            
            tableBody.appendChild(tr);
        });
        
        console.log("Таблица построена, применяем фильтры");
        
        // Применяем текущие фильтры после построения таблицы
        const searchValue = document.getElementById('searchInput').value;
        applySearchFilter(searchValue);
    }
    
    // Функция для создания итоговой строки
    function addTotalRow() {
        console.log("Выполняется addTotalRow()");
        
        // Суммируемые поля
        const sumFields = [
            'fb_impressions', 'fb_spend', 'fb_link_click', 'fb_video_view', 
            'fb_page_engagement', 'fb_post_engagement', 'fb_post_reaction', 
            'kt_unic_clicks', 'regs', 'deps', 'income', 'bprofit', 'fb_clicks'
        ];
        
        // Проверяем, включен ли фильтр "Активные" или поиск
        const activeOnly = document.getElementById('activeOnlyFilter').checked;
        console.log("Фильтр 'Активные' включен:", activeOnly);
        
        const searchValue = document.getElementById('searchInput').value;
        console.log("Поисковый запрос:", searchValue);
        
        // Учитываем также наличие column-filters
        const isFiltered = activeOnly || searchValue.trim() !== '' || Object.keys(activeFilters).length > 0;
        console.log("Применяется фильтрация:", isFiltered);
        
        // Вычисляем суммы
        const totals = {};
        
        // Всегда используем видимые строки для расчета итогов, если есть фильтрация
        if (isFiltered) {
            console.log("Используем логику фильтрации для расчета итогов");
            
            // Получаем все строки
            const allRows = document.querySelectorAll('#statsTable tbody tr:not(.total-row)');
            console.log("Всего строк в таблице (без итоговой):", allRows.length);
            
            // Получаем только видимые строки (более надежный селектор)
            const visibleRows = Array.from(allRows).filter(row => {
                return window.getComputedStyle(row).display !== 'none';
            });
            console.log("Видимых строк после фильтрации:", visibleRows.length);
            
            if (visibleRows.length > 0) {
                console.log("Расчет итогов по видимым строкам");
                // Считаем итоги по видимым строкам
                visibleRows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    console.log(`Обрабатываем строку с ${cells.length} ячейками`);
                    
                    // Получаем и логируем fb_effective_status для отладки
                    const statusIndex = selectedColumns.indexOf('fb_effective_status');
                    if (statusIndex !== -1 && statusIndex < cells.length) {
                        console.log("Статус строки:", cells[statusIndex].textContent);
                    }
                    
                    sumFields.forEach(field => {
                        const columnIndex = selectedColumns.indexOf(field);
                        if (columnIndex !== -1 && columnIndex < cells.length) {
                            if (!totals[field]) totals[field] = 0;
                            
                            // Получаем значение из ячейки
                            let cell = cells[columnIndex];
                            let value = cell ? cell.textContent : '0';
                            
                            // Удаляем символы форматирования и конвертируем в число
                            value = value.replace(/[^\d.-]/g, '');
                            value = parseFloat(value || 0);
                            
                            if (!isNaN(value)) {
                                totals[field] += value;
                                if (field === 'fb_spend') {
                                    console.log(`Прибавляем ${value} к итогу по fb_spend, текущая сумма: ${totals[field]}`);
                                }
                            }
                        }
                    });
                });
            } else {
                console.log("Видимых строк не найдено, используем программную фильтрацию");
                
                // Если видимых строк нет, используем программную фильтрацию
                const filteredData = currentTableData.filter(item => {
                    // Проверка фильтра "Активные"
                    if (activeOnly && (!item.fb_effective_status || item.fb_effective_status.toUpperCase() !== 'ACTIVE')) {
                        return false;
                    }
                    
                    // Проверка поиска
                    if (searchValue.trim() !== '') {
                        let matchesSearch = false;
                        // Проверяем все выбранные колонки
                        for (const column of selectedColumns) {
                            const value = item[column];
                            if (value && String(value).toLowerCase().includes(searchValue.toLowerCase())) {
                                matchesSearch = true;
                                break;
                            }
                        }
                        if (!matchesSearch) {
                            return false;
                        }
                    }
                    
                    // Проверка column-фильтров
                    if(Object.keys(activeFilters).length){
                        for(const [col,vals] of Object.entries(activeFilters)){
                            if(!vals.includes(String(item[col]))) return false;
                        }
                    }
                    
                    return true;
                });
                
                console.log("Отфильтровано записей программно:", filteredData.length);
                console.log("Примеры отфильтрованных данных:", filteredData.slice(0, 3));
                
                // Считаем итоги по отфильтрованным данным
                filteredData.forEach(item => {
                    sumFields.forEach(field => {
                        if (!totals[field]) totals[field] = 0;
                        let value = item[field];
                        if (typeof value === 'string') {
                            value = value.replace(/[^\d.-]/g, '');
                        }
                        value = parseFloat(value || 0);
                        if (!isNaN(value)) {
                            totals[field] += value;
                            if (field === 'fb_spend') {
                                console.log(`Прибавляем ${value} к итогу по fb_spend, текущая сумма: ${totals[field]}`);
                            }
                        }
                    });
                });
            }
            
            console.log("Итоговые значения после фильтрации:", totals);
        } else {
            console.log("Фильтрация не применена, считаем по всем данным");
            
            // Если фильтры не используются, считаем по всем данным
            currentTableData.forEach(item => {
                sumFields.forEach(field => {
                    if (!totals[field]) totals[field] = 0;
                    // Удаляем символы форматирования и конвертируем в число
                    let value = item[field];
                    if (typeof value === 'string') {
                        value = value.replace(/[^\d.-]/g, '');
                    }
                    value = parseFloat(value || 0);
                    if (!isNaN(value)) {
                        totals[field] += value;
                    }
                });
            });
            
            console.log("Итоговые значения без фильтрации:", totals);
        }
        
        // Перед рендером рассчитываемDerived метрики по формулам
        applyCalculated(totals);

        // Создаем итоговую строку
        const tableBody = document.getElementById('tableBody');
        const totalRow = document.createElement('tr');
        totalRow.classList.add('total-row');
        
        // Создаем ячейки итоговой строки
        selectedColumns.forEach(column => {
            const td = document.createElement('td');
            
            // Добавляем специальные классы для колонок ad_id и last_update
            if (column === 'ad_id') {
                td.classList.add('column-ad_id');
            } else if (column === 'last_update') {
                td.classList.add('column-last_update');
            }
            
            if (column === 'date_log' || column === selectedColumns[0]) {
                if (isFiltered) {
                    td.textContent = 'ИТОГО (отфильтровано):';
                } else {
                    td.textContent = 'ИТОГО:';
                }
            } else if (sumFields.includes(column) || calcColumns.includes(column)) {
                // Форматируем числа в зависимости от типа данных
                if (column.includes('spend') || column.includes('cpc') || column.includes('cpm')) {
                    td.textContent = totals[column] ? totals[column].toFixed(2) : '-';
                    td.classList.add('numeric-cell');
                } else if (column.includes('ctr') || column.includes('cr')) {
                    td.textContent = totals[column] ? totals[column].toFixed(2) + '%' : '-';
                    td.classList.add('percent-cell');
                } else if (column === 'cpi' || column === 'cpr') {
                    td.textContent = totals[column] ? totals[column].toFixed(2) : '-';
                    td.classList.add('numeric-cell');
                } else {
                    td.textContent = totals[column] ? Math.round(totals[column]).toString() : '-';
                    td.classList.add('numeric-cell');
                }
            } else {
                td.textContent = '-';
            }
            
            totalRow.appendChild(td);
        });
        
        tableBody.appendChild(totalRow);
        
        console.log("Строка ИТОГО добавлена в таблицу");
    }
    
    // Функция для построения модального окна выбора колонок
    function buildColumnSelectionModal() {
        const columnCheckboxes = document.getElementById('columnCheckboxes');
        columnCheckboxes.innerHTML = '';
        
        // Создаем чекбоксы для каждой колонки
        allColumns.forEach(column => {
            const checkboxContainer = document.createElement('div');
            checkboxContainer.className = 'column-checkbox-container';
            checkboxContainer.dataset.column = column;
            
            const dragHandle = document.createElement('div');
            dragHandle.className = 'drag-handle';
            dragHandle.innerHTML = '<i class="fas fa-grip-vertical"></i>';
            
            const formCheck = document.createElement('div');
            formCheck.className = 'form-check';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'form-check-input column-checkbox';
            checkbox.id = `col-${column}`;
            checkbox.checked = selectedColumns.includes(column);
            checkbox.value = column;
            
            // Добавляем обработчик события change для автоматического перемещения выбранных колонок вверх
            checkbox.addEventListener('change', function() {
                setTimeout(function() { sortCheckedColumnsToTop(); }, 0);
            });
            
            const label = document.createElement('label');
            label.className = 'form-check-label';
            label.htmlFor = `col-${column}`;
            label.textContent = column;
            
            formCheck.appendChild(checkbox);
            formCheck.appendChild(label);
            
            checkboxContainer.appendChild(dragHandle);
            checkboxContainer.appendChild(formCheck);
            
            columnCheckboxes.appendChild(checkboxContainer);
        });
        
        // Делаем колонки перетаскиваемыми
        setupDragAndDrop();
        
        // Сортируем список, чтобы выбранные были сверху
        sortCheckedColumnsToTop();
    }
    
    // Функция для настройки drag-and-drop
    function setupDragAndDrop() {
        const containers = document.querySelectorAll('.column-checkbox-container');
        
        containers.forEach(container => {
            container.setAttribute('draggable', true);
            
            container.addEventListener('dragstart', function() {
                this.classList.add('dragging');
            });
            
            container.addEventListener('dragend', function() {
                this.classList.remove('dragging');
            });
        });
        
        const columnSelectionContainer = document.querySelector('.column-selection-container');
        
        columnSelectionContainer.addEventListener('dragover', function(e) {
            e.preventDefault();
            const draggable = document.querySelector('.dragging');
            const afterElement = getDragAfterElement(this, e.clientY);
            
            if (afterElement == null) {
                this.appendChild(draggable);
            } else {
                this.insertBefore(draggable, afterElement);
            }
        });
    }
    
    // Вспомогательная функция для определения позиции при перетаскивании
    function getDragAfterElement(container, y) {
        const dragableElements = [...container.querySelectorAll('.column-checkbox-container:not(.dragging)')];
        
        return dragableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }
    
    // Функция для сортировки таблицы
    function sortTable(column) {
        const headerCells = document.querySelectorAll('#statsTable th');
        let sortDirection = 'asc';
        
        // Находим ячейку заголовка для данной колонки
        const headerCell = Array.from(headerCells).find(cell => cell.textContent === column);
        
        // Определяем направление сортировки
        if (headerCell.classList.contains('sorting_asc')) {
            sortDirection = 'desc';
            headerCell.classList.remove('sorting_asc');
            headerCell.classList.add('sorting_desc');
        } else {
            sortDirection = 'asc';
            headerCell.classList.remove('sorting_desc');
            headerCell.classList.add('sorting_asc');
        }
        
        // Сбрасываем классы сортировки у всех других заголовков
        headerCells.forEach(cell => {
            if (cell !== headerCell) {
                cell.classList.remove('sorting_asc', 'sorting_desc');
            }
        });
        
        // Сохраняем информацию о текущей сортировке
        currentSortColumn = column;
        currentSortDirection = sortDirection;
        
        // Сортируем данные
        currentTableData.sort((a, b) => {
            let valA = a[column] || '';
            let valB = b[column] || '';
            
            // Преобразуем строковые значения в числа если это возможно
            if (!isNaN(parseFloat(valA)) && !isNaN(parseFloat(valB))) {
                valA = parseFloat(valA);
                valB = parseFloat(valB);
            } else if (typeof valA === 'string' && typeof valB === 'string') {
                // Для строковых значений делаем сравнение без учета регистра
                valA = valA.toLowerCase();
                valB = valB.toLowerCase();
            }
            
            // Сравниваем значения
            if (valA < valB) {
                return sortDirection === 'asc' ? -1 : 1;
            } else if (valA > valB) {
                return sortDirection === 'asc' ? 1 : -1;
            }
            return 0;
        });
        
        // Перестраиваем таблицу без обновления источника, чтобы сортировка не сбрасывалась
        buildTable(true);
    }
    
    // Функция для применения фильтра поиска
    function applySearchFilter(searchTerm) {
        console.log("Применяем фильтр, поисковый запрос:", searchTerm);
        
        const tableRows = document.querySelectorAll('#statsTable tbody tr:not(.total-row)');
        console.log("Всего строк для фильтрации:", tableRows.length);
        
        const searchTermLower = searchTerm.toLowerCase();
        const activeOnly = document.getElementById('activeOnlyFilter').checked;
        console.log("Фильтр 'Активные' включен:", activeOnly);
        
        let visibleRowCount = 0;
        
        // Удаляем существующую итоговую строку, если она есть
        const existingTotalRow = document.querySelector('#statsTable tbody tr.total-row');
        if (existingTotalRow) {
            existingTotalRow.remove();
            console.log("Удалена существующая итоговая строка");
        }
        
        tableRows.forEach(row => {
            const cells = row.querySelectorAll('td');
            let rowMatches = false;
            let isActive = false;
            
            // Проверяем соответствие поисковому запросу
            if (searchTerm === '') {
                rowMatches = true; // Если поисковый запрос пустой, считаем что строка соответствует поиску
            } else {
                cells.forEach(cell => {
                    if (cell.textContent.toLowerCase().includes(searchTermLower)) {
                        rowMatches = true;
                    }
                });
            }
            
            // Проверяем, активный ли статус
            cells.forEach((cell, index) => {
                const columnName = selectedColumns[index];
                if (columnName === 'fb_effective_status') {
                    const status = cell.textContent.trim().toUpperCase();
                    // Логируем статусы для отладки
                    console.log("Строка, статус:", status);
                    if (status === 'ACTIVE') {
                        isActive = true;
                    }
                }
            });
            
            // Проверяем соответствие активным column-фильтрам
            let passesColumnFilters = true;
            if(Object.keys(activeFilters).length){
                passesColumnFilters = Object.entries(activeFilters).every(([col,vals])=>{
                    const idx = selectedColumns.indexOf(col);
                    if(idx===-1||idx>=cells.length) return false;
                    return vals.includes(cells[idx].textContent.trim());
                });
            }

            const showRow = rowMatches && (!activeOnly || isActive) && passesColumnFilters;
            console.log(`Строка ${isActive ? 'ACTIVE' : 'не ACTIVE'}, показывать: ${showRow}`);
            
            // Устанавливаем видимость строки
            row.style.display = showRow ? '' : 'none';
            
            if (showRow) {
                visibleRowCount++;
            }
        });
        
        console.log("Видимых строк после фильтрации:", visibleRowCount);
        
        // Если нет видимых строк, добавляем сообщение
        const noDataMessage = document.getElementById('noDataMessage');
        if (visibleRowCount === 0) {
            if (!noDataMessage) {
                const tableContainer = document.querySelector('.table-container');
                const message = document.createElement('div');
                message.id = 'noDataMessage';
                message.className = 'alert alert-info mt-3';
                message.innerHTML = '<i class="fas fa-info-circle"></i> Нет данных для отображения.';
                
                if (activeOnly) {
                    message.innerHTML += ' Попробуйте отключить фильтр "Активные".';
                }
                
                tableContainer.appendChild(message);
                console.log("Добавлено сообщение об отсутствии данных");
            }
        } else if (noDataMessage) {
            noDataMessage.remove();
            console.log("Удалено сообщение об отсутствии данных");
        }
        
        // Добавляем новую итоговую строку после фильтрации
        addTotalRow();
    }
    
    // Обработчик для поиска
    searchInput.addEventListener('input', function() {
        applySearchFilter(this.value);
    });
    
    // Обработчик для переключателя "Активные"
    activeOnlyFilter.addEventListener('change', function() {
        // Сохраняем состояние переключателя в localStorage
        try {
            localStorage.setItem('fbStatsActiveOnly', this.checked);
        } catch (e) {
            console.error('Ошибка при сохранении состояния переключателя "Активные":', e);
        }
        
        // Изменяем стиль лейбла
        const label = document.querySelector('label[for="activeOnlyFilter"]');
        if (this.checked) {
            label.classList.add('active-filter-enabled');
        } else {
            label.classList.remove('active-filter-enabled');
        }
        
        // Применяем фильтр заново
        console.log("Изменено состояние фильтра 'Активные', применяем фильтр");
        applySearchFilter(searchInput.value);
    });
    
    // Обработчик для чекбокса "Выбрать все"
    const selectAllCheckbox = document.getElementById('selectAllColumns');
    selectAllCheckbox.addEventListener('change', function() {
        const columnCheckboxes = document.querySelectorAll('.column-checkbox');
        columnCheckboxes.forEach(checkbox => {
            checkbox.checked = this.checked;
        });
    });
    
    // Обработчик для кнопки "Сбросить"
    const resetButton = document.getElementById('resetToDefaultColumns');
    resetButton.addEventListener('click', function() {
        const columnCheckboxes = document.querySelectorAll('.column-checkbox');
        columnCheckboxes.forEach(checkbox => {
            checkbox.checked = initialDefaultColumns.includes(checkbox.value);
        });
        selectAllCheckbox.checked = false;
    });
    
    // Обработчик для кнопки "Сохранить как шаблон"
    const saveAsDefaultButton = document.getElementById('saveAsDefaultColumns');
    saveAsDefaultButton.addEventListener('click', function() {
        const selectedCheckboxes = document.querySelectorAll('.column-checkbox:checked');
        const selectedValues = Array.from(selectedCheckboxes).map(checkbox => checkbox.value);
        
        localStorage.setItem('fbStatsDefaultColumns', JSON.stringify(selectedValues));
        alert('Настройки сохранены как шаблон по умолчанию');
    });
    
    // Обработчик для кнопки "Применить"
    const saveButton = document.getElementById('saveColumnSelection');
    saveButton.addEventListener('click', function() {
        // Собираем выбранные колонки в порядке их расположения
        const columnContainers = document.querySelectorAll('.column-checkbox-container');
        selectedColumns = [];
        
        columnContainers.forEach(container => {
            const checkbox = container.querySelector('.column-checkbox');
            if (checkbox.checked) {
                selectedColumns.push(checkbox.value);
            }
        });
        
        // Сохраняем выбранные колонки
        localStorage.setItem('fbStatsColumnSettings', JSON.stringify(selectedColumns));
        
        // Перестраиваем таблицу
        buildTable();
    });
    
    // Функция для сортировки колонок - выбранные вверху
    function sortCheckedColumnsToTop() {
        var containers = document.querySelectorAll('.column-checkbox-container');
        if (containers.length === 0) return;
        
        var parent = containers[0].parentNode;
        
        // Собираем выбранные и невыбранные контейнеры
        var checked = [];
        var unchecked = [];
        
        for (var i = 0; i < containers.length; i++) {
            var container = containers[i];
            var checkbox = container.querySelector('.column-checkbox');
            if (checkbox && checkbox.checked) {
                checked.push(container);
            } else {
                unchecked.push(container);
            }
        }
        
        // Удаляем все контейнеры
        while (parent.querySelector('.column-checkbox-container')) {
            parent.removeChild(parent.querySelector('.column-checkbox-container'));
        }
        
        // Добавляем сначала выбранные, потом невыбранные
        for (var j = 0; j < checked.length; j++) {
            parent.appendChild(checked[j]);
        }
        
        for (var k = 0; k < unchecked.length; k++) {
            parent.appendChild(unchecked[k]);
        }
    }
    
    // Инициализация (строим модальное окно колонок без построения таблицы)
    buildColumnSelectionModal();

    // ------------------ Логика агрегации при скрытом date_log ------------------
    const nameColumns = ['id_acc_bd','rk_id','camp_id','adset_id','ad_id','geo_buying','creo_id','app_id','type_optimization','fb_objective','time_zone','kt_campaign_name','kt_campaign_id','comment','rk_limit','creative_thumbnail_url','ad_name','adset_name','camp_name','rk_cur','rk_name','install_or_dep'];
    const statusColumns = ['fb_effective_status','fb_status','install_or_dep','live_status','ad_effective_status','adset_status','adset_effective_status','camp_status','camp_effective_status'];
    const sumColumns = ['fb_impressions','fb_spend','fb_link_click','fb_video_view','fb_page_engagement','fb_post_engagement','fb_post_reaction','kt_unic_clicks','regs','deps','income','fb_clicks'];
    const calcColumns = ['fb_cpc','fb_cpm','fb_ctr','c2i','cr2i','cpi','i2r','cr2r','cpr','cr2d','r2s','cps','bprofit','broi'];
    const updateColumns = ['last_update','last_update_fbt','last_update_kt'];
    const skipColumns  = ['fb_quality_score_organic','fb_quality_score_ectr','fb_quality_score_ecvr','fb_cost_per_unique_click'];

    function safeDiv(a, b) { return b !== 0 ? a / b : 0; }

    function toNumber(v) {
        if (v === null || v === undefined || v === '' || v === '-') return 0;
        if (typeof v === 'number') return v;
        const s = String(v).replace(/,/g, '.'); // десятичная запятая → точка
        return parseFloat(s.replace(/[^\d.-]/g, '')) || 0;
    }

    function applyCalculated(row) {
        row.fb_cpc  = safeDiv(row.fb_spend, row.fb_clicks);
        row.fb_cpm  = safeDiv(row.fb_spend, row.fb_impressions / 1000);
        row.fb_ctr  = safeDiv(row.fb_clicks, row.fb_impressions) * 100;
        row.c2i     = safeDiv(row.fb_clicks, row.kt_unic_clicks);
        row.cr2i    = safeDiv(row.kt_unic_clicks, row.fb_clicks) * 100;
        row.cpi     = safeDiv(row.fb_spend, row.kt_unic_clicks);
        row.i2r     = safeDiv(row.kt_unic_clicks, row.regs);
        row.cr2r    = safeDiv(row.regs, row.kt_unic_clicks) * 100;
        row.cpr     = safeDiv(row.fb_spend, row.regs);
        row.cr2d    = safeDiv(row.deps, row.regs) * 100;
        row.r2s     = safeDiv(row.regs, row.deps);
        row.cps     = safeDiv(row.fb_spend, row.deps);
        row.bprofit = (row.income || 0) - (row.fb_spend || 0);
        row.broi    = safeDiv(row.income, row.fb_spend) * 100;
    }

    function aggregateStats(data) {
        // Группируем по ВСЕМ «Название»-колонкам, которые видимы (selectedColumns)
        const visibleNameCols = nameColumns.filter(col => selectedColumns.includes(col));
        const includeDate = selectedColumns.includes('date_log');

        // Если ни одной видимой «Название»-колонки нет, используем приоритетный fallback
        const priority = ['ad_id','adset_id','camp_id','rk_id','id_acc_bd'];

        // Функция формирования ключа из строки колонок (составной ключ)
        const buildKey = item => {
            const parts = [];
            if(includeDate) parts.push(String(item.date_log ?? '').trim());
            visibleNameCols.forEach(c=>parts.push(String(item[c] ?? '').trim()));
            return parts.join('||');
        };
        const usingCompositeKey = includeDate || visibleNameCols.length > 0; // если хотя бы одна «Название»-колонка видима

        // Если нет видимых «Название»-колонок, fallback-колонка (ad_id → ...)
        let keyColumn = usingCompositeKey ? null : priority.find(col => col in (data[0] || {}));

        const map = new Map();

        data.forEach(item => {
            // Строим ключ группировки
            const key = usingCompositeKey ? buildKey(item) : (keyColumn ? String(item[keyColumn] ?? '').trim() : '___all');
            let agg = map.get(key);
            if (!agg) {
                agg = {};
                // Сохраняем ключевые поля чтобы не потерять в агрегате
                if(includeDate) agg.date_log = item.date_log;
                // Если одиночный ключ → сохраняем колонку, если составной — просто нули
                if (!usingCompositeKey && keyColumn) {
                    agg[keyColumn] = item[keyColumn];
                }
                sumColumns.forEach(c => { agg[c] = 0; });
                map.set(key, agg);
            }

            // гарантируем отображение всех «Название»-полей (берём первое попавшееся значение)
            nameColumns.forEach(c => {
                if (agg[c] === undefined || agg[c] === null || agg[c] === '-') {
                    agg[c] = item[c];
                }
            });

            // суммируем метрики
            sumColumns.forEach(c => { agg[c] += toNumber(item[c]); });

            // берём самые свежие статусы/апдейты
            const curDate = new Date(agg.date_log || '1970-01-01');
            const newDate = new Date(item.date_log);
            if (newDate > curDate) {
                statusColumns.concat(updateColumns).forEach(c => { agg[c] = item[c]; });
                agg.date_log = item.date_log;
            }
        });

        const result = Array.from(map.values()).map(row => {
            applyCalculated(row);
            skipColumns.forEach(c => { row[c] = '-'; });
            return row;
        });
        return result;
    }

    let currentTableData = statsData;

    function refreshDataSource() {
        console.log('--- refreshDataSource ---');
        console.log('selectedColumns содержит date_log?', selectedColumns.includes('date_log'));
        console.log('selectedColumns:', selectedColumns);
        console.log('statsData length:', statsData.length);
        currentTableData = aggregateStats(statsData);
        console.log('currentTableData length после refresh:', currentTableData.length);
    }

    // Временная отладочная функция: проверяем сумму fb_spend по ad_id и сравниваем с агрегированной
    function verifyAggregationForAd(targetAdId) {
        const origSum = statsData.filter(r => String(r.ad_id) === String(targetAdId)).reduce((acc, r) => acc + toNumber(r.fb_spend), 0);
        const aggRow = aggregateStats(statsData).find(r => String(r.ad_id) === String(targetAdId));
        const aggSum = aggRow ? toNumber(aggRow.fb_spend) : 0;
        console.log(`Проверка агрегации для ad_id=${targetAdId}: исходная сумма=${origSum.toFixed(2)}, после aggregateStats=${aggSum.toFixed(2)}`);
    }

    // Немедленная проверка после загрузки скрипта
    verifyAggregationForAd('120224350299670191');

    // Теперь, когда классификация колонок объявлена, строим таблицу и применяем фильтр поиска
    buildTable();
    applySearchFilter(searchInput.value);

    // ---------- Генерация CSV ----------
    function generateCsv() {
        const header = selectedColumns.slice();
        const rows = [];

        // видимые строки (исключаем скрытые и итоговую)
        const visibleRows = Array.from(document.querySelectorAll('#statsTable tbody tr:not(.total-row)'))
            .filter(r => window.getComputedStyle(r).display !== 'none');

        visibleRows.forEach(row => {
            const cells = row.querySelectorAll('td');
            const rowData = [];
            header.forEach((_, idx) => {
                const cellText = cells[idx] ? cells[idx].textContent.trim() : '';
                // экранируем запятые/кавычки
                const cleaned = '"' + cellText.replace(/"/g,'""') + '"';
                rowData.push(cleaned);
            });
            rows.push(rowData.join(','));
        });

        // Добавим итоговую строку, если есть
        const totalRow = document.querySelector('#statsTable tbody tr.total-row');
        if (totalRow) {
            const cells = totalRow.querySelectorAll('td');
            const totalData = header.map((_, idx) => {
                const cellText = cells[idx] ? cells[idx].textContent.trim() : '';
                return '"' + cellText.replace(/"/g,'""') + '"';
            });
            rows.push(totalData.join(','));
        }

        const csvString = '"' + header.join('","') + '"\n' + rows.join('\n');
        const blob = new Blob([csvString], {type: 'text/csv;charset=utf-8;'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'facebook_stats.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    document.getElementById('downloadCsvBtn').addEventListener('click', generateCsv);
});
</script>
{% endblock %} 